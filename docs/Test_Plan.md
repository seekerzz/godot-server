# 混合现实乒乓球游戏 - 测试计划

**版本**: 1.0
**日期**: 2026-02-21
**引擎**: Godot 4.6
**语言**: GDScript
**测试工具**: GUT (Godot Unit Testing)

---

## 目录

1. [测试策略和范围](#1-测试策略和范围)
2. [功能测试用例](#2-功能测试用例)
3. [性能测试方案](#3-性能测试方案)
4. [自动化测试脚本规划](#4-自动化测试脚本规划)
5. [Bug跟踪流程](#5-bug跟踪流程)
6. [关键测试场景清单](#6-关键测试场景清单)

---

## 0. Week 1 核心测试用例（优先实现）

### 0.1 核心测试用例清单

| 测试ID | 测试项 | 优先级 | 测试方法 | 对应文档章节 |
|--------|--------|--------|----------|-------------|
| TC-001 | UDP数据包接收 | P0 | 模拟发送数据包，验证接收 | 2.1 TC-SENSOR-001 |
| TC-002 | 四元数旋转映射 | P0 | 验证手机旋转与球拍同步 | 2.2 TC-PADDLE-002 |
| TC-003 | 弹性回中算法 | P0 | 测试位置漂移纠正效果 | 2.2 TC-PADDLE-003 |
| TC-004 | 校准流程 | P0 | 验证4步校准可完成 | 2.2 TC-PADDLE-004 |
| TC-005 | 球拍实体创建 | P0 | 验证3D球拍正确显示 | 2.2 实体创建测试 |

### 0.2 性能测试基准

| 指标 | 目标值 | 测试工具 | 测试场景 |
|------|--------|----------|----------|
| 目标帧率 | 60 FPS | Godot Profiler | 完整对局 |
| 最大延迟 | 50ms | 自定义延迟统计 | 传感器→显示 |
| 内存占用 | <256 MB | OS监控工具 | 30分钟游戏 |
| 启动时间 | <3秒 | 计时器 | 冷启动到主菜单 |

---

## 1. 测试策略和范围

### 1.1 测试目标

| 目标编号 | 目标描述 | 验收标准 |
|---------|---------|---------|
| T-001 | 确保传感器数据准确映射到虚拟球拍 | 延迟 < 50ms, 位置误差 < 5cm |
| T-002 | 验证击球判定系统的准确性 | 误检率 < 5%, 漏检率 < 3% |
| T-003 | 保证AI对手行为符合设计预期 | 各难度参数偏差 < 10% |
| T-004 | 确认物理系统真实可信 | 球速范围 3-25 m/s, 反弹系数 0.85±0.05 |
| T-005 | 确保游戏流程完整可用 | 所有状态转换正常, 无阻塞 |
| T-006 | 验证UI交互响应及时 | 点击响应 < 100ms, 动画流畅 |

### 1.2 测试阶段划分

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         测试阶段流程图                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│   ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────┐ │
│   │  单元测试   │───▶│  集成测试   │───▶│  系统测试   │───▶│ 验收测试│ │
│   │  (Week 1-2) │    │  (Week 3)   │    │  (Week 4)   │    │(Week 5) │ │
│   └─────────────┘    └─────────────┘    └─────────────┘    └─────────┘ │
│          │                  │                  │                │      │
│          ▼                  ▼                  ▼                ▼      │
│   ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────┐ │
│   │ 核心函数    │    │ 模块间      │    │ 端到端      │    │ 用户    │ │
│   │ 算法逻辑    │    │ 接口联调    │    │ 完整流程    │    │ 体验验证│ │
│   └─────────────┘    └─────────────┘    └─────────────┘    └─────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 阶段详细说明

| 阶段 | 时间 | 测试重点 | 通过标准 |
|------|------|---------|---------|
| **单元测试** | Week 1-2 | 独立函数、算法、工具类 | 代码覆盖率 > 80%, 全部通过 |
| **集成测试** | Week 3 | 传感器-球拍、球拍-物理、AI-球 | 接口数据流正确, 时序正常 |
| **系统测试** | Week 4 | 完整游戏流程、网络通信 | 无阻塞bug, 流程完整 |
| **验收测试** | Week 5 | 用户体验、手感验证 | 策划/总监签字确认 |

### 1.3 通过标准

#### 功能通过标准

| 类别 | 标准 | 测量方法 |
|------|------|---------|
| 功能完整性 | 100% 需求功能实现 | 需求追踪矩阵检查 |
| 功能正确性 | 核心功能零严重bug | 功能测试用例100%通过 |
| 兼容性 | 支持目标平台 | 平台兼容性测试 |

#### 性能通过标准

| 指标 | 目标值 | 最低要求 | 测试工具 |
|------|--------|---------|---------|
| 渲染帧率 | 60 FPS | 45 FPS | Godot Profiler |
| 物理更新 | 120 Hz | 60 Hz | 自定义计时器 |
| 输入延迟 | < 50ms | < 100ms | 网络抓包+帧分析 |
| 网络延迟 | < 20ms | < 50ms | Ping测试 |
| 内存占用 | < 256MB | < 512MB | OS监控工具 |

#### 稳定性通过标准

| 场景 | 测试时长 | 通过标准 |
|------|---------|---------|
| 长时间游戏 | 2小时 | 无崩溃, 无内存泄漏 |
| 频繁暂停/恢复 | 50次循环 | 状态正确, 无数据丢失 |
| 网络断连恢复 | 20次循环 | 自动重连, 数据同步 |

### 1.4 风险区域识别

| 风险编号 | 风险描述 | 影响程度 | 发生概率 | 缓解措施 |
|---------|---------|---------|---------|---------|
| R-001 | 传感器数据漂移导致位置计算失效 | 高 | 中 | 弹性回中算法+定期校准 |
| R-002 | UDP丢包导致控制延迟/跳跃 | 高 | 中 | 插值补偿+丢包重连机制 |
| R-003 | 击球判定时机不准确 | 高 | 中 | 时间窗口+预测算法 |
| R-004 | AI难度曲线不合理 | 中 | 低 | 动态调整+参数热更新 |
| R-005 | 物理引擎穿模问题 | 中 | 中 | 连续碰撞检测+碰撞体优化 |
| R-006 | 长时间运行内存泄漏 | 中 | 低 | 定期内存监控+对象池 |

---

## 2. 功能测试用例

### 2.1 传感器数据接收测试

#### TC-SENSOR-001: UDP数据包接收

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-SENSOR-001 |
| **测试项** | UDP传感器数据包接收与解析 |
| **前置条件** | 1. PC端服务器已启动<br>2. 手机端传感器应用运行<br>3. 网络连接正常 |
| **测试步骤** | 1. 启动服务器监听端口49555<br>2. 手机发送二进制传感器数据包<br>3. 观察数据接收状态<br>4. 检查解析后的数值 |
| **预期结果** | 1. 服务器状态显示"已连接"<br>2. 每16ms接收一个数据包<br>3. 加速度值范围在±20 m/s²<br>4. 四元数模长接近1.0 |
| **优先级** | P0 (阻塞) |

#### TC-SENSOR-002: 网络断连恢复

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-SENSOR-002 |
| **测试项** | 网络中断后的自动恢复 |
| **前置条件** | 传感器连接正常, 数据持续接收 |
| **测试步骤** | 1. 断开WiFi连接5秒<br>2. 恢复WiFi连接<br>3. 观察重连过程<br>4. 验证数据恢复 |
| **预期结果** | 1. 断连3秒内显示"连接丢失"<br>2. 10秒内自动重连成功<br>3. 数据流恢复正常<br>4. 球拍位置平滑过渡 |
| **优先级** | P1 (高) |

#### TC-SENSOR-003: 数据包乱序处理

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-SENSOR-003 |
| **测试项** | UDP数据包乱序/丢包处理 |
| **前置条件** | 使用网络模拟工具制造丢包 |
| **测试步骤** | 1. 设置10%丢包率<br>2. 持续接收数据60秒<br>3. 观察球拍运动平滑度<br>4. 检查异常检测触发 |
| **预期结果** | 1. 球拍无跳跃式移动<br>2. 丢包补偿机制生效<br>3. 异常值被过滤<br>4. 连续异常触发安全模式 |
| **优先级** | P1 (高) |

### 2.2 球拍控制映射测试

#### TC-PADDLE-001: 位置映射准确性

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-PADDLE-001 |
| **测试项** | 手机物理运动到虚拟位置的映射 |
| **前置条件** | 传感器已校准, 处于初始位置 |
| **测试步骤** | 1. 手机向前挥动30cm<br>2. 手机向左移动20cm<br>3. 手机向上举起15cm<br>4. 记录虚拟球拍位置变化 |
| **预期结果** | 1. Z轴正向移动约0.3m<br>2. X轴负向移动约0.2m<br>3. Y轴正向移动约0.15m<br>4. 各轴运动独立无耦合 |
| **优先级** | P0 (阻塞) |

#### TC-PADDLE-002: 旋转同步精度

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-PADDLE-002 |
| **测试项** | 手机旋转到球拍姿态的同步 |
| **前置条件** | 完成姿态校准流程 |
| **测试步骤** | 1. 手机平放(屏幕朝上)<br>2. 向右旋转90度<br>3. 向前翻转45度<br>4. 检查球拍姿态 |
| **预期结果** | 1. 球拍面水平<br>2. 球拍面向右倾斜90度<br>3. 球拍面前倾45度<br>4. 旋转响应延迟 < 50ms |
| **优先级** | P0 (阻塞) |

#### TC-PADDLE-003: 弹性回中算法

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-PADDLE-003 |
| **测试项** | 弹性回中算法的正确性 |
| **前置条件** | 球拍处于非中心位置 |
| **测试步骤** | 1. 快速挥拍后停止移动<br>2. 观察球拍回中过程<br>3. 测量回中时间<br>4. 检查边界限制 |
| **预期结果** | 1. 速度按friction系数衰减<br>2. 2-3秒内回到中心区域<br>3. 位置不超过max_displacement<br>4. 回中过程平滑无抖动 |
| **优先级** | P1 (高) |

#### TC-PADDLE-004: 校准流程验证

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-PADDLE-004 |
| **测试项** | 4步姿态校准流程 |
| **前置条件** | 首次连接或重置校准 |
| **测试步骤** | 1. 启动校准流程<br>2. 按提示完成4个姿势<br>3. 保存校准数据<br>4. 验证校准效果 |
| **预期结果** | 1. 每步有清晰图文指引<br>2. 数据正确记录<br>3. 校准文件成功保存<br>4. 后续姿态映射准确 |
| **优先级** | P1 (高) |

### 2.3 击球判定系统测试

#### TC-HIT-001: 有效击球检测

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-HIT-001 |
| **测试项** | 有效击球动作的检测 |
| **前置条件** | 球在击球范围内, 冷却完毕 |
| **测试步骤** | 1. 球接近球拍(距离<0.5m)<br>2. 以>2m/s速度挥拍<br>3. 球拍朝向球(角度<60度)<br>4. 执行击球动作 |
| **预期结果** | 1. 检测到击球事件<br>2. 触发击球音效和特效<br>3. 球速度方向改变<br>4. 进入0.3秒冷却期 |
| **优先级** | P0 (阻塞) |

#### TC-HIT-002: 击球冷却机制

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-HIT-002 |
| **测试项** | 击球冷却期防止连击 |
| **前置条件** | 刚完成一次击球 |
| **测试步骤** | 1. 完成有效击球<br>2. 在0.3秒内再次挥拍<br>3. 观察第二次是否生效<br>4. 等待冷却结束后再次尝试 |
| **预期结果** | 1. 冷却期内第二次挥拍无效<br>2. 无重复击球音效<br>3. 冷却结束后可正常击球<br>4. 冷却指示器显示正确 |
| **优先级** | P1 (高) |

#### TC-HIT-003: 击球力量计算

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-HIT-003 |
| **测试项** | 击球力量分级计算 |
| **前置条件** | 球在可击球位置 |
| **测试步骤** | 1. 轻推挥拍(速度<2m/s)<br>2. 正常挥拍(速度4-6m/s)<br>3. 大力挥拍(速度>8m/s)<br>4. 检查输出球速 |
| **预期结果** | 1. 轻推: 球速5-8 m/s<br>2. 正常: 球速8-12 m/s<br>3. 大力: 球速12-20 m/s<br>4. 力量条UI显示对应等级 |
| **优先级** | P1 (高) |

#### TC-HIT-004: 击球方向控制

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-HIT-004 |
| **测试项** | 通过挥拍方向控制球路 |
| **前置条件** | 球在击球点 |
| **测试步骤** | 1. 向左挥拍击球<br>2. 向右挥拍击球<br>3. 向上挑球<br>4. 向下扣杀 |
| **预期结果** | 1. 球向左飞行<br>2. 球向右飞行<br>3. 球向上过网<br>4. 球快速下压 |
| **优先级** | P1 (高) |

### 2.4 AI行为测试

#### TC-AI-001: 难度参数验证

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-AI-001 |
| **测试项** | 各难度级别参数正确性 |
| **前置条件** | 游戏处于对战状态 |
| **测试步骤** | 1. 选择"简单"难度<br>2. 记录AI反应时间和移动速度<br>3. 切换到"困难"难度<br>4. 对比参数变化 |
| **预期结果** | 1. 简单: 反应0.4s, 移速1.5m/s<br>2. 困难: 反应0.15s, 移速4.0m/s<br>3. 参数切换即时生效<br>4. 难度差异明显可感知 |
| **优先级** | P1 (高) |

#### TC-AI-002: 球路预测准确性

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-AI-002 |
| **测试项** | AI对球路的预测能力 |
| **前置条件** | AI处于接球准备状态 |
| **测试步骤** | 1. 向AI左侧击球<br>2. 向AI右侧击球<br>3. 向AI近网击球<br>4. 观察AI移动预判 |
| **预期结果** | 1. AI提前向左侧移动<br>2. AI提前向右侧移动<br>3. AI向前移动接短球<br>4. 专家难度预判准确率>95% |
| **优先级** | P1 (高) |

#### TC-AI-003: 动态难度调整

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-AI-003 |
| **测试项** | DDA系统根据比分自动调整 |
| **前置条件** | 开启动态难度, 普通难度 |
| **测试步骤** | 1. 玩家连续得3分<br>2. 观察AI反应速度变化<br>3. AI连续得3分<br>4. 观察AI反应速度变化 |
| **预期结果** | 1. AI反应速度+10%<br>2. AI移动更积极<br>3. AI反应速度-10%<br>4. 调整幅度不超过±20% |
| **优先级** | P2 (中) |

#### TC-AI-004: AI击球类型选择

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-AI-004 |
| **测试项** | AI根据球况选择击球类型 |
| **前置条件** | AI准备击球 |
| **测试步骤** | 1. 给AI高球(高度>1.5m)<br>2. 给AI近网球<br>3. 给AI普通回球<br>4. 观察AI选择的击球方式 |
| **预期结果** | 1. 高球触发扣杀<br>2. 近网触发推挡<br>3. 普通球使用平击或旋转<br>4. 击球类型与文档一致 |
| **优先级** | P2 (中) |

### 2.5 物理系统测试

#### TC-PHYS-001: 球速范围验证

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-PHYS-001 |
| **测试项** | 球的线速度范围控制 |
| **前置条件** | 球处于可击球状态 |
| **测试步骤** | 1. 最小力量击球<br>2. 中等力量击球<br>3. 最大力量扣杀<br>4. 测量球速 |
| **预期结果** | 1. 最小速度 >= 3 m/s<br>2. 典型速度 8-12 m/s<br>3. 最大速度 <= 25 m/s<br>4. 速度限制器生效 |
| **优先级** | P1 (高) |

#### TC-PHYS-002: 球台反弹物理

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-PHYS-002 |
| **测试项** | 球与球台碰撞反弹 |
| **前置条件** | 球向球台下落 |
| **测试步骤** | 1. 从不同高度释放球<br>2. 观察反弹高度<br>3. 测量反弹角度<br>4. 检查摩擦影响 |
| **预期结果** | 1. 反弹高度约为落下高度的85%<br>2. 反弹角度符合入射角<br>3. 切向速度受摩擦衰减<br>4. 旋转影响反弹轨迹 |
| **优先级** | P1 (高) |

#### TC-PHYS-003: 马格努斯效应

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-PHYS-003 |
| **测试项** | 旋转球的马格努斯效应 |
| **前置条件** | 球带有旋转角速度 |
| **测试步骤** | 1. 给球添加上旋<br>2. 给球添加下旋<br>3. 给球添加侧旋<br>4. 观察轨迹偏移 |
| **预期结果** | 1. 上旋球落地后加速<br>2. 下旋球落地后减速/回跳<br>3. 侧旋球横向偏移<br>4. 旋转逐渐衰减 |
| **优先级** | P2 (中) |

#### TC-PHYS-004: 连续碰撞检测

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-PHYS-004 |
| **测试项** | 高速球的连续碰撞检测 |
| **前置条件** | 球速 > 20 m/s |
| **测试步骤** | 1. 发射高速球向球拍<br>2. 观察碰撞检测<br>3. 检查是否穿模<br>4. 验证碰撞响应 |
| **预期结果** | 1. 4步连续碰撞检测生效<br>2. 无穿模现象<br>3. 碰撞点计算准确<br>4. 反弹速度合理 |
| **优先级** | P1 (高) |

### 2.6 UI交互测试

#### TC-UI-001: 主菜单导航

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-UI-001 |
| **测试项** | 主菜单按钮交互 |
| **前置条件** | 游戏启动, 显示主菜单 |
| **测试步骤** | 1. 点击"开始游戏"<br>2. 点击"难度选择"切换选项<br>3. 点击"教程"<br>4. 点击"设置" |
| **预期结果** | 1. 进入校准/游戏流程<br>2. 难度选项循环切换<br>3. 进入教程场景<br>4. 打开设置面板 |
| **优先级** | P1 (高) |

#### TC-UI-002: HUD信息显示

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-UI-002 |
| **测试项** | 游戏内HUD信息更新 |
| **前置条件** | 游戏进行中 |
| **测试步骤** | 1. 玩家得分<br>2. AI得分<br>3. 挥拍击球<br>4. 观察HUD变化 |
| **预期结果** | 1. 玩家分数正确增加<br>2. AI分数正确增加<br>3. 力量条实时显示<br>4. 球拍速度数值更新 |
| **优先级** | P1 (高) |

#### TC-UI-003: 暂停菜单功能

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-UI-003 |
| **测试项** | 暂停菜单各项功能 |
| **前置条件** | 游戏进行中 |
| **测试步骤** | 1. 按ESC键暂停<br>2. 点击"继续"<br>3. 再次暂停, 点击"重新开始"<br>4. 再次暂停, 点击"返回主菜单" |
| **预期结果** | 1. 游戏暂停, 菜单显示<br>2. 游戏恢复<br>3. 重新开始当前对局<br>4. 返回主菜单 |
| **优先级** | P1 (高) |

#### TC-UI-004: 校准界面交互

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-UI-004 |
| **测试项** | 校准流程的UI交互 |
| **前置条件** | 进入校准场景 |
| **测试步骤** | 1. 查看步骤指引<br>2. 点击"确定"记录姿态<br>3. 点击"跳过校准"<br>4. 完成所有步骤 |
| **预期结果** | 1. 显示当前步骤动画指引<br>2. 记录数据并进入下一步<br>3. 直接进入游戏(使用默认校准)<br>4. 显示完成提示并进入游戏 |
| **优先级** | P1 (高) |

### 2.7 游戏流程测试

#### TC-FLOW-001: 完整对局流程

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-FLOW-001 |
| **测试项** | 从菜单到比赛结束的完整流程 |
| **前置条件** | 游戏启动, 手机已连接 |
| **测试步骤** | 1. 主菜单选择开始游戏<br>2. 完成校准流程<br>3. 进行一局11分制比赛<br>4. 查看结算界面 |
| **预期结果** | 1. 进入校准场景<br>2. 校准完成后进入游戏<br>3. 计分正确, 回合正常<br>4. 显示最终比分和统计 |
| **优先级** | P0 (阻塞) |

#### TC-FLOW-002: 得分判定逻辑

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-FLOW-002 |
| **测试项** | 各种得分情况的判定 |
| **前置条件** | 游戏进行中 |
| **测试步骤** | 1. 球出界未触台<br>2. 球触网后出界<br>3. 球未过网<br>4. 球触台两次 |
| **预期结果** | 1. 对方得分<br>2. 对方得分<br>3. 对方得分<br>4. 击球方得分 |
| **优先级** | P1 (高) |

#### TC-FLOW-003: 比赛胜负判定

| 属性 | 内容 |
|------|------|
| **测试ID** | TC-FLOW-003 |
| **测试项** | 11分制胜负判定规则 |
| **前置条件** | 比分接近11分 |
| **测试步骤** | 1. 10:10平局<br>2. 一方12:10获胜<br>3. 检查是否需要继续<br>4. 验证胜利条件 |
| **预期结果** | 1. 进入延长赛<br>2. 领先2分者获胜<br>3. 10:10后需领先2分<br>4. 正确触发胜利界面 |
| **优先级** | P1 (高) |

---

## 3. 性能测试方案

### 3.1 帧率稳定性测试

#### PERF-001: 渲染帧率测试

| 属性 | 内容 |
|------|------|
| **测试ID** | PERF-001 |
| **测试目标** | 确保游戏稳定运行在60FPS |
| **测试环境** | 目标PC配置 (i5/16GB/GTX1060) |
| **测试步骤** | 1. 使用Godot Profiler监控<br>2. 进行5分钟完整对局<br>3. 记录FPS曲线<br>4. 统计掉帧次数 |
| **通过标准** | 1. 平均FPS >= 58<br>2. 1% Low FPS >= 45<br>3. 掉帧次数 < 10次/分钟<br>4. 无持续卡顿 |
| **测试工具** | Godot Profiler, 自定义FPS记录器 |

#### PERF-002: 物理更新频率

| 属性 | 内容 |
|------|------|
| **测试ID** | PERF-002 |
| **测试目标** | 物理引擎更新频率稳定 |
| **测试步骤** | 1. 启用物理调试信息<br>2. 进行高速对拉测试<br>3. 监控_physics_process调用<br>4. 检查碰撞检测耗时 |
| **通过标准** | 1. 物理更新 >= 60Hz<br>2. 单次更新 < 4ms<br>3. 连续碰撞检测无遗漏<br>4. 物理线程不阻塞渲染 |
| **测试工具** | Engine.get_frames_per_second(), 自定义计时器 |

### 3.2 网络延迟测试

#### PERF-003: UDP通信延迟

| 属性 | 内容 |
|------|------|
| **测试ID** | PERF-003 |
| **测试目标** | 传感器数据传输延迟 |
| **测试步骤** | 1. 在数据包添加时间戳<br>2. 计算端到端延迟<br>3. 测试不同网络环境<br>4. 统计延迟分布 |
| **通过标准** | 1. 平均延迟 < 20ms<br>2. 95%分位延迟 < 50ms<br>3. 最大延迟 < 100ms<br>4. 局域网内稳定 |
| **测试工具** | 自定义延迟统计器, Wireshark |

#### PERF-004: 丢包率测试

| 属性 | 内容 |
|------|------|
| **测试ID** | PERF-004 |
| **测试目标** | 评估丢包对游戏体验的影响 |
| **测试步骤** | 1. 使用Clumsy模拟丢包<br>2. 设置1%/5%/10%丢包率<br>3. 测试球拍控制流畅度<br>4. 评估用户体验 |
| **通过标准** | 1. <3%丢包无明显感知<br>2. 5%丢包可接受<br>3. 10%丢包有补偿机制<br>4. 插值平滑无跳跃 |
| **测试工具** | Clumsy (网络模拟工具) |

### 3.3 内存占用监控

#### PERF-005: 内存使用测试

| 属性 | 内容 |
|------|------|
| **测试ID** | PERF-005 |
| **测试目标** | 控制内存占用, 防止泄漏 |
| **测试步骤** | 1. 游戏启动时记录内存<br>2. 进行30分钟连续游戏<br>3. 每5分钟记录内存快照<br>4. 检查对象分配情况 |
| **通过标准** | 1. 初始内存 < 128MB<br>2. 30分钟后增长 < 20%<br>3. 无持续增长趋势<br>4. 垃圾回收正常 |
| **测试工具** | OS内存监控, Godot Debugger |

#### PERF-006: 对象池效率

| 属性 | 内容 |
|------|------|
| **测试ID** | PERF-006 |
| **测试目标** | 特效和临时对象复用 |
| **测试步骤** | 1. 高频触发击球特效<br>2. 监控对象创建/销毁<br>3. 检查对象池命中率<br>4. 评估GC压力 |
| **通过标准** | 1. 对象复用率 > 80%<br>2. 无频繁GC停顿<br>3. 特效池大小合理<br>4. 内存分配平稳 |
| **测试工具** | 自定义对象池监控 |

### 3.4 传感器数据处理性能

#### PERF-007: 数据处理耗时

| 属性 | 内容 |
|------|------|
| **测试ID** | PERF-007 |
| **测试目标** | 传感器数据处理链路的性能 |
| **测试步骤** | 1. 在关键函数插入计时<br>2. 测量数据解析时间<br>3. 测量滤波算法耗时<br>4. 测量坐标转换耗时 |
| **通过标准** | 1. 数据解析 < 0.1ms<br>2. 滤波处理 < 0.5ms<br>3. 坐标转换 < 0.2ms<br>4. 单帧总处理 < 1ms |
| **测试工具** | Time.get_ticks_usec(), 自定义性能分析器 |

---

## 4. 自动化测试脚本规划

### 4.1 单元测试规划

#### 4.1.1 测试目录结构

```
tests/
├── unit/
│   ├── test_sensor_fusion.gd
│   ├── test_paddle_calibration.gd
│   ├── test_swing_detector.gd
│   ├── test_hit_detector.gd
│   ├── test_ball_physics.gd
│   ├── test_ai_controller.gd
│   ├── test_score_manager.gd
│   └── test_math_utils.gd
├── integration/
│   ├── test_sensor_to_paddle.gd
│   ├── test_paddle_to_physics.gd
│   ├── test_ai_ball_interaction.gd
│   └── test_game_flow.gd
├── performance/
│   ├── test_frame_rate.gd
│   ├── test_memory_usage.gd
│   └── test_network_latency.gd
└── fixtures/
    ├── mock_sensor_data.gd
    ├── test_data_factory.gd
    └── constants.gd
```

#### 4.1.2 核心单元测试清单

| 测试文件 | 测试函数 | 测试内容 |
|---------|---------|---------|
| test_sensor_fusion.gd | test_low_pass_filter() | 低通滤波器正确性 |
| test_sensor_fusion.gd | test_spike_detection() | 异常值检测 |
| test_sensor_fusion.gd | test_coordinate_conversion() | 坐标系转换 |
| test_paddle_calibration.gd | test_calibration_offset() | 校准偏移计算 |
| test_paddle_calibration.gd | test_quaternion_normalization() | 四元数归一化 |
| test_swing_detector.gd | test_swing_threshold() | 挥拍阈值检测 |
| test_swing_detector.gd | test_power_calculation() | 力量计算 |
| test_hit_detector.gd | test_hit_timing_window() | 击球时间窗口 |
| test_hit_detector.gd | test_cooldown_mechanism() | 冷却机制 |
| test_ball_physics.gd | test_gravity_application() | 重力应用 |
| test_ball_physics.gd | test_bounce_calculation() | 反弹计算 |
| test_ball_physics.gd | test_magnus_effect() | 马格努斯效应 |
| test_ai_controller.gd | test_difficulty_params() | 难度参数应用 |
| test_ai_controller.gd | test_ball_prediction() | 球路预测 |
| test_score_manager.gd | test_score_increment() | 分数增加 |
| test_score_manager.gd | test_win_condition() | 胜利条件 |

#### 4.1.3 单元测试示例代码

```gdscript
# tests/unit/test_hit_detector.gd
extends GutTest

var hit_detector: HitDetector

func before_each():
    hit_detector = HitDetector.new()
    add_child_autofree(hit_detector)

func test_hit_timing_window():
    # 测试击球时间窗口计算
    var ball_pos = Vector3(0, 1, 0)
    var paddle_pos = Vector3(0, 1, 0.3)
    var relative_vel = Vector3(0, 0, -5)

    var result = hit_detector.evaluate_hit_opportunity(ball_pos, paddle_pos, relative_vel)

    assert_true(result.can_hit, "Should detect hit opportunity")
    assert_almost_eq(result.time_to_impact, 0.06, 0.01, "Time to impact should be ~0.06s")

func test_cooldown_mechanism():
    # 测试冷却机制
    hit_detector.hit_cooldown = 0.3
    hit_detector.execute_hit(null, {})

    assert_false(hit_detector.can_hit_ball(), "Should not allow hit during cooldown")

    await wait_seconds(0.35)
    assert_true(hit_detector.can_hit_ball(), "Should allow hit after cooldown")

func test_hit_direction_calculation():
    # 测试击球方向计算
    var swing_data = {
        "velocity": Vector3(1, 0, -5),
        "power": 0.8
    }

    var direction = hit_detector.calculate_hit_direction(swing_data)

    assert_gt(direction.z, 0, "Direction should be forward (positive Z)")
    assert_gt(direction.y, 0.2, "Should have minimum upward angle")
```

### 4.2 集成测试场景

#### 4.2.1 传感器到球拍集成测试

```gdscript
# tests/integration/test_sensor_to_paddle.gd
extends GutTest

func test_sensor_data_to_paddle_position():
    # 模拟传感器数据流
    var sensor_server = mock(SensorServerCore)
    var paddle = autoqfree(Paddle.new())
    var processor = autoqfree(SensorProcessor.new())

    # 模拟向前加速度
    var mock_data = {
        "linear_accel": Vector3(0, 0, 5),
        "quaternion": Quaternion.IDENTITY
    }

    processor.on_raw_data_received(mock_data)
    await wait_frames(10)

    # 验证球拍向前移动
    assert_gt(paddle.position.z, 0, "Paddle should move forward")
    assert_lt(paddle.position.z, 1.0, "Paddle should be within max displacement")
```

#### 4.2.2 击球物理链集成测试

```gdscript
# tests/integration/test_hit_physics_chain.gd
extends GutTest

func test_hit_to_ball_movement():
    # 测试完整击球到球运动的链路
    var paddle = autoqfree(Paddle.new())
    var ball = autoqfree(Ball.new())
    var physics_world = autoqfree(PhysicsWorld.new())

    # 设置初始状态
    ball.global_position = Vector3(0, 1, 0)
    paddle.global_position = Vector3(0, 1, 0.5)

    # 执行击球
    var hit_info = {
        "direction": Vector3(0, 0.3, 1).normalized(),
        "force": 15.0,
        "spin": Vector3(0, 10, 0)
    }
    ball.on_paddle_hit(hit_info)

    # 模拟物理更新
    await wait_frames(60)

    # 验证球已向前运动
    assert_gt(ball.global_position.z, 0, "Ball should move forward")
    assert_gt(ball.linear_velocity.length(), 5.0, "Ball should have significant velocity")
```

### 4.3 回归测试策略

#### 4.3.1 回归测试触发条件

| 触发条件 | 回归测试范围 | 预计耗时 |
|---------|-------------|---------|
| 传感器相关代码修改 | 传感器+球拍+击球检测 | 5分钟 |
| 物理引擎参数调整 | 物理系统+碰撞检测+AI | 10分钟 |
| AI算法修改 | AI系统+完整对局 | 15分钟 |
| UI界面修改 | UI系统+游戏流程 | 5分钟 |
| 每日构建 | 全部自动化测试 | 30分钟 |

#### 4.3.2 回归测试套件

```gdscript
# tests/regression/regression_suite.gd
extends GutTest

# 核心回归测试 - 每次提交必须通过
func test_core_gameplay_loop():
    # 测试核心游戏循环
    var game = autoqfree(GameScene.new())

    # 启动游戏
    game.start_match()
    assert_eq(game.state_machine.current_state, GameStateMachine.State.SERVING)

    # 发球
    game.serve_ball()
    assert_eq(game.state_machine.current_state, GameStateMachine.State.PLAYING)

    # 模拟几个回合
    for i in range(5):
        await wait_for_rally_end(game)
        assert_true(game.score_manager.has_valid_score(), "Score should be valid after rally")

    # 结束游戏
    game.end_match()
    assert_eq(game.state_machine.current_state, GameStateMachine.State.MATCH_END)

# 完整回归测试 - 每日构建运行
func test_full_match_simulation():
    # 模拟完整比赛
    var simulator = autoqfree(MatchSimulator.new())
    var result = await simulator.simulate_full_match()

    assert_true(result.completed, "Match should complete")
    assert_true(result.winner in ["player", "ai"], "Should have a winner")
    assert_gt(result.total_rallies, 10, "Should have reasonable number of rallies")
```

---

## 5. Bug跟踪流程

### 5.1 严重程度分级

| 级别 | 定义 | 响应时间 | 修复期限 | 示例 |
|------|------|---------|---------|------|
| **Critical** | 导致游戏崩溃或无法进行的bug | 立即 | 24小时 | 游戏启动崩溃, 传感器完全失效 |
| **High** | 严重影响游戏体验的bug | 4小时内 | 3天 | 击球判定失效, AI行为异常 |
| **Medium** | 影响部分功能但不阻塞流程的bug | 1天内 | 1周 | UI显示错误, 音效缺失 |
| **Low** | 轻微问题或优化建议 | 3天内 | 下次迭代 | 文字拼写错误, 视觉微调 |

### 5.2 处理流程

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         Bug处理流程图                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌────────┐│
│  │ 发现Bug │───▶│ 记录Bug │───▶│ 评估分级│───▶│ 分配修复│───▶│ 修复中 ││
│  └─────────┘    └─────────┘    └─────────┘    └─────────┘    └────────┘│
│                                              │               │         │
│                                              ▼               ▼         │
│                                         ┌─────────┐    ┌─────────┐    │
│                                         │ 延期处理│    │ 提交修复│    │
│                                         │ (Low)   │    └────┬────┘    │
│                                         └─────────┘         │         │
│                                                               ▼         │
│                                                          ┌─────────┐   │
│                                                          │ 验证测试│   │
│                                                          └────┬────┘   │
│                                                               │         │
│                           ┌───────────────────────────────────┘         │
│                           ▼                                             │
│                    ┌─────────────┐                                      │
│                    │   关闭Bug   │                                      │
│                    │ (已验证修复)│                                      │
│                    └─────────────┘                                      │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 5.3 报告模板

#### Bug报告模板

```markdown
## Bug报告

**ID**: BUG-[编号]
**标题**: [简要描述]
**报告人**: [姓名]
**日期**: [YYYY-MM-DD]
**严重程度**: [Critical/High/Medium/Low]
**优先级**: [P0/P1/P2/P3]
**模块**: [传感器/球拍/物理/AI/UI/网络/其他]

### 环境信息
- **Godot版本**: 4.6
- **操作系统**: [Windows 10/11]
- **硬件配置**: [CPU/GPU/RAM]
- **网络环境**: [局域网/互联网]

### 复现步骤
1. [步骤1]
2. [步骤2]
3. [步骤3]

### 预期结果
[描述应该发生什么]

### 实际结果
[描述实际发生了什么]

### 附件
- [截图/录屏链接]
- [日志文件]
- [测试数据]

### 备注
[其他相关信息]
```

#### Bug修复报告模板

```markdown
## Bug修复报告

**Bug ID**: BUG-[编号]
**修复人**: [姓名]
**修复日期**: [YYYY-MM-DD]
**关联提交**: [Git Commit Hash]

### 根因分析
[详细描述bug的根本原因]

### 修复方案
[描述如何修复]

### 修改文件
- [文件1]: [修改说明]
- [文件2]: [修改说明]

### 测试验证
- [ ] 单元测试通过
- [ ] 集成测试通过
- [ ] 手动验证通过
- [ ] 回归测试通过

### 验证步骤
1. [验证步骤1]
2. [验证步骤2]

### 影响评估
[修复可能带来的副作用或影响范围]
```

---

## 6. 关键测试场景清单

### 6.1 传感器精度测试场景

#### SC-001: 静态精度测试

| 属性 | 内容 |
|------|------|
| **场景ID** | SC-001 |
| **场景名称** | 静态姿态保持精度 |
| **测试目的** | 验证手机静止时虚拟球拍无漂移 |
| **测试步骤** | 1. 将手机平放在桌面<br>2. 保持静止30秒<br>3. 记录球拍位置和旋转<br>4. 分析漂移量 |
| **通过标准** | 1. 位置漂移 < 1cm/30s<br>2. 旋转漂移 < 2度/30s<br>3. 无累积性漂移 |
| **测试频率** | 每次构建 |

#### SC-002: 动态响应测试

| 属性 | 内容 |
|------|------|
| **场景ID** | SC-002 |
| **场景名称** | 快速挥拍响应测试 |
| **测试目的** | 验证快速运动时的跟踪精度 |
| **测试步骤** | 1. 执行标准挥拍动作<br>2. 录制传感器数据和球拍轨迹<br>3. 对比实际运动与虚拟运动<br>4. 计算延迟和误差 |
| **通过标准** | 1. 端到端延迟 < 50ms<br>2. 轨迹形状匹配度 > 90%<br>3. 峰值速度误差 < 10% |
| **测试频率** | 每周 |

#### SC-003: 极限运动测试

| 属性 | 内容 |
|------|------|
| **场景ID** | SC-003 |
| **场景名称** | 极限加速度测试 |
| **测试目的** | 验证传感器在极限条件下的稳定性 |
| **测试步骤** | 1. 快速甩动手机(模拟扣杀)<br>2. 突然停止运动<br>3. 旋转手机180度<br>4. 检查数据异常 |
| **通过标准** | 1. 无数据溢出<br>2. 异常检测正确触发<br>3. 恢复后正常工作 |
| **测试频率** | 每次传感器算法修改 |

### 6.2 击球手感验证场景

#### SC-004: 击球时机窗口

| 属性 | 内容 |
|------|------|
| **场景ID** | SC-004 |
| **场景名称** | 击球时机容错测试 |
| **测试目的** | 确定最佳击球时机窗口 |
| **测试步骤** | 1. 设置不同提前量(-0.1s到+0.05s)<br>2. 在每种时机尝试击球<br>3. 记录击球成功率<br>4. 绘制成功曲线 |
| **通过标准** | 1. 最佳窗口 >= 0.1s<br>2. 窗口中心成功率 > 95%<br>3. 边缘成功率 > 70% |
| **测试频率** | 每次击球判定修改 |

#### SC-005: 力量控制精度

| 属性 | 内容 |
|------|------|
| **场景ID** | SC-005 |
| **场景名称** | 力量分级控制测试 |
| **测试目的** | 验证不同力量挥拍的区分度 |
| **测试步骤** | 1. 轻推(20%力量)<br>2. 中等(50%力量)<br>3. 大力(80%力量)<br>4. 扣杀(100%力量)<br>5. 测量输出球速 |
| **通过标准** | 1. 各级球速有明显区分<br>2. 同级力量输出稳定<br>3. 力量与球速呈正相关 |
| **测试频率** | 每周 |

#### SC-006: 方向控制精度

| 属性 | 内容 |
|------|------|
| **场景ID** | SC-006 |
| **场景名称** | 击球方向控制测试 |
| **测试目的** | 验证通过挥拍方向控制球路的能力 |
| **测试步骤** | 1. 向左挥拍击球<br>2. 向右挥拍击球<br>3. 向上挑球<br>4. 测量落点分布 |
| **通过标准** | 1. 左右控制区分度 > 80%<br>2. 落点方差 < 0.5m<br>3. 方向与预期一致 |
| **测试频率** | 每周 |

### 6.3 AI难度曲线验证场景

#### SC-007: 难度区分度测试

| 属性 | 内容 |
|------|------|
| **场景ID** | SC-007 |
| **场景名称** | AI难度级别区分度 |
| **测试目的** | 验证不同难度AI有明显差异 |
| **测试步骤** | 1. 同一玩家 vs 简单AI<br>2. 同一玩家 vs 困难AI<br>3. 记录比分和回合数<br>4. 对比统计数据 |
| **通过标准** | 1. 简单AI胜率 < 30%<br>2. 困难AI胜率 > 70%<br>3. 平均回合时长递减 |
| **测试频率** | 每次AI参数调整 |

#### SC-008: 动态难度调整

| 属性 | 内容 |
|------|------|
| **场景ID** | SC-008 |
| **场景名称** | DDA系统有效性 |
| **测试目的** | 验证动态难度调整的有效性 |
| **测试步骤** | 1. 故意连续失分给AI<br>2. 观察AI是否降低难度<br>3. 连续得分<br>4. 观察AI是否增加难度 |
| **通过标准** | 1. 3分差距触发调整<br>2. 调整幅度符合设计<br>3. 比赛趋于胶着 |
| **测试频率** | 每次DDA算法修改 |

#### SC-009: AI失误合理性

| 属性 | 内容 |
|------|------|
| **场景ID** | SC-009 |
| **场景名称** | AI失误率合理性 |
| **测试目的** | 验证AI失误符合难度设定 |
| **测试步骤** | 1. 进行100回合测试<br>2. 统计各难度AI失误次数<br>3. 分析失误类型分布<br>4. 检查失误时机 |
| **通过标准** | 1. 失误率符合设计参数<br>2. 失误分布随机<br>3. 关键时刻失误合理 |
| **测试频率** | 每月 |

### 6.4 长时间稳定性测试场景

#### SC-010: 连续游戏稳定性

| 属性 | 内容 |
|------|------|
| **场景ID** | SC-010 |
| **场景名称** | 2小时连续游戏测试 |
| **测试目的** | 验证长时间运行的稳定性 |
| **测试步骤** | 1. 启动游戏<br>2. 连续进行多局比赛<br>3. 每30分钟记录状态<br>4. 2小时后检查各项指标 |
| **通过标准** | 1. 无崩溃<br>2. 内存增长 < 20%<br>3. 帧率稳定<br>4. 传感器连接稳定 |
| **测试频率** | 每周 |

#### SC-011: 频繁暂停恢复

| 属性 | 内容 |
|------|------|
| **场景ID** | SC-011 |
| **场景名称** | 暂停恢复压力测试 |
| **测试目的** | 验证状态切换的稳定性 |
| **测试步骤** | 1. 游戏进行中<br>2. 每10秒暂停/恢复<br>3. 循环50次<br>4. 检查状态一致性 |
| **通过标准** | 1. 无状态错乱<br>2. 分数正确<br>3. 球位置正确<br>4. 无内存泄漏 |
| **测试频率** | 每次状态机修改 |

#### SC-012: 网络断连恢复

| 属性 | 内容 |
|------|------|
| **场景ID** | SC-012 |
| **场景名称** | 网络断连恢复测试 |
| **测试目的** | 验证网络异常后的恢复能力 |
| **测试步骤** | 1. 正常游戏<br>2. 断开WiFi 5秒<br>3. 恢复WiFi<br>4. 观察重连过程<br>5. 循环20次 |
| **通过标准** | 1. 10秒内自动重连<br>2. 球拍位置平滑过渡<br>3. 游戏可继续<br>4. 无数据丢失 |
| **测试频率** | 每次网络代码修改 |

---

## 附录

### A. 测试环境配置

#### 推荐测试PC配置

| 组件 | 最低配置 | 推荐配置 |
|------|---------|---------|
| CPU | Intel i5-8400 | Intel i7-10700 |
| RAM | 16GB DDR4 | 32GB DDR4 |
| GPU | GTX 1060 6GB | RTX 3060 |
| 存储 | 256GB SSD | 512GB NVMe SSD |
| 网络 | 100Mbps LAN | 1Gbps LAN |
| 显示器 | 1080p 60Hz | 1440p 144Hz |

#### 测试手机要求

| 项目 | 要求 |
|------|------|
| 系统 | Android 10+ |
| 传感器 | 加速度计 + 陀螺仪 |
| 刷新率 | 60Hz IMU采样 |
| 网络 | 5GHz WiFi |

### B. 测试工具清单

| 工具 | 用途 | 获取方式 |
|------|------|---------|
| GUT | Godot单元测试 | Asset Library |
| Godot Profiler | 性能分析 | 内置 |
| Wireshark | 网络抓包 | 官网下载 |
| Clumsy | 网络模拟 | GitHub |
| OBS Studio | 录屏记录 | 官网下载 |
| MSI Afterburner | 硬件监控 | 官网下载 |

### C. 测试数据记录表

| 测试日期 | 测试人员 | 测试版本 | 通过用例 | 失败用例 | 备注 |
|---------|---------|---------|---------|---------|------|
| | | | | | |

---

**文档结束**
